generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")

  // Planetscale does not support foreign keys, so we will leverage indexes and Prisma relations
  relationMode = "prisma"
}

model User {
  id            String             @id @db.VarChar(12)
  archivedAt    DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  email         String             @unique
  firstName     String             @db.Text
  roles         UserRole[]
  sessions      Session[]
  exercises     Exercise[]
  organizations UserOrganization[]
}

model Organization {
  id            String             @id @db.VarChar(12)
  name          String             @db.Text
  archivedAt    DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  organizations UserOrganization[]
}

model UserOrganization {
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String       @db.VarChar(12)
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String       @db.VarChar(12)

  @@id([userId, organizationId])
  @@index([userId])
  @@index([organizationId])
}

model Role {
  id         String     @id @db.VarChar(12)
  archivedAt DateTime?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  name       String     @db.Text
  users      UserRole[]
}

model UserRole {
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.VarChar(12)
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId String @db.VarChar(12)

  @@id([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

model Session {
  id        String   @id @db.VarChar(12)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @db.VarChar(12)
  expiresAt DateTime

  @@index([userId])
}

model Exercise {
  id         String    @id @db.VarChar(12)
  archivedAt DateTime?
  createdAt  DateTime  @default(now())
  name       String    @db.Text
  updatedAt  DateTime  @updatedAt
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  sets       Set[]

  @@index([userId])
  @@fulltext([name])
}

model Workout {
  id          String    @id @db.VarChar(12)
  archivedAt  DateTime?
  createdAt   DateTime  @default(now())
  completedAt DateTime?
  name        String    @db.Text
  updatedAt   DateTime  @updatedAt
  userId      String    @db.VarChar(12)
  sets        Set[]

  @@index([userId])
}

model AmountUnit {
  id         String    @id @db.VarChar(12)
  name       String    @db.Text
  delimiter  String    @unique
  archivedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  sets       Set[]

  @@map("WorkoutSetAmountUnit")
}

model Set {
  id         String     @id @db.VarChar(12)
  archivedAt DateTime?
  amount     Int?
  createdAt  DateTime   @default(now())
  exercise   Exercise   @relation(fields: [exerciseId], references: [id], onDelete: Restrict)
  exerciseId String     @db.VarChar(12)
  unit       AmountUnit @relation(fields: [unitId], references: [id])
  unitId     String
  updatedAt  DateTime   @updatedAt
  userId     String     @db.VarChar(12)
  volume     Int
  workout    Workout    @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  workoutId  String     @db.VarChar(12)
  tags       SetTag[]
  groups     SetGroup[]

  @@index([exerciseId])
  @@index([unitId])
  @@index([workoutId])
  @@map("WorkoutSet")
}

model SetTagType {
  id         String    @id @db.VarChar(12)
  name       String    @db.Text
  archivedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  sets       SetTag[]

  @@map("WorkoutSetTagType")
}

model SetTag {
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  type      SetTagType @relation(fields: [typeId], references: [id], onDelete: Cascade)
  typeId    String     @db.VarChar(12)
  set       Set        @relation(fields: [setId], references: [id], onDelete: Cascade)
  setId     String     @db.VarChar(12)

  @@id([typeId, setId])
  @@index([typeId])
  @@index([setId])
  @@map("WorkoutSetTag")
}

model SetGroupType {
  id         String     @id @db.VarChar(12)
  archivedAt DateTime?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  name       String     @db.Text
  groups     SetGroup[]

  @@map("WorkoutSetGroupType")
}

model SetGroup {
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  type      SetGroupType @relation(fields: [typeId], references: [id])
  typeId    String       @db.VarChar(12)
  set       Set          @relation(fields: [setId], references: [id], onDelete: Cascade)
  setId     String       @unique @db.VarChar(12)

  @@id([typeId, setId])
  @@index([typeId])
  @@index([setId])
  @@map("WorkoutSetGroup")
}

model Waitlist {
  id        String   @id @db.VarChar(12)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String   @unique
  firstName String   @db.Text
}
